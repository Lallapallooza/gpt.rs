# gpt_rs.kernel: dynamic_slice_f32_rank4
# gpt_rs.symbol: gpt_rs_triton_dynamic_slice_f32_rank4
# gpt_rs.signature: in_ptr=*fp32,starts_ptr=*i32,out_ptr=*fp32,n=i32,od0=i32,od1=i32,od2=i32,od3=i32,is0=i32,is1=i32,is2=i32,is3=i32,mx0=i32,mx1=i32,mx2=i32,mx3=i32,start_offset=i32
# gpt_rs.param_abi: *fp32,*i32,*fp32,u32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,i32,*opaque
# gpt_rs.constexpr: BLOCK_SIZE=256
# gpt_rs.num_warps: 8

import triton
import triton.language as tl


@triton.jit
def gpt_rs_triton_dynamic_slice_f32_rank4(
    in_ptr,
    starts_ptr,
    out_ptr,
    n,
    od0,
    od1,
    od2,
    od3,
    is0,
    is1,
    is2,
    is3,
    mx0,
    mx1,
    mx2,
    mx3,
    start_offset,
    BLOCK_SIZE: tl.constexpr,
):
    pid = tl.program_id(0)
    idx = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)
    mask = idx < n

    s0_idx = 0 - start_offset
    s1_idx = 1 - start_offset
    s2_idx = 2 - start_offset
    s3_idx = 3 - start_offset

    st0_raw = tl.load(starts_ptr + tl.maximum(s0_idx, 0), mask=s0_idx >= 0, other=0)
    st1_raw = tl.load(starts_ptr + tl.maximum(s1_idx, 0), mask=s1_idx >= 0, other=0)
    st2_raw = tl.load(starts_ptr + tl.maximum(s2_idx, 0), mask=s2_idx >= 0, other=0)
    st3_raw = tl.load(starts_ptr + tl.maximum(s3_idx, 0), mask=s3_idx >= 0, other=0)

    st0 = tl.minimum(tl.maximum(st0_raw, 0), mx0)
    st1 = tl.minimum(tl.maximum(st1_raw, 0), mx1)
    st2 = tl.minimum(tl.maximum(st2_raw, 0), mx2)
    st3 = tl.minimum(tl.maximum(st3_raw, 0), mx3)

    plane23 = od2 * od3
    plane123 = od1 * plane23

    o0 = idx // plane123
    rem0 = idx - o0 * plane123
    o1 = rem0 // plane23
    rem1 = rem0 - o1 * plane23
    o2 = rem1 // od3
    o3 = rem1 - o2 * od3

    i0 = o0 + st0
    i1 = o1 + st1
    i2 = o2 + st2
    i3 = o3 + st3

    in_off = i0 * is0 + i1 * is1 + i2 * is2 + i3 * is3
    values = tl.load(in_ptr + in_off, mask=mask, other=0.0)
    tl.store(out_ptr + idx, values, mask=mask)
