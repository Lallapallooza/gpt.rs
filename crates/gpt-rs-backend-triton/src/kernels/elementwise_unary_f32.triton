# gpt_rs.kernel: elementwise_unary_f32
# gpt_rs.symbol: gpt_rs_triton_ewise_unary_f32
# gpt_rs.signature: in_ptr=*fp32,out_ptr=*fp32,n=i32,op=i32
# gpt_rs.param_abi: *fp32,*fp32,u32,u32,*opaque
# gpt_rs.constexpr: BLOCK_SIZE=256
# gpt_rs.num_warps: 8

import triton
import triton.language as tl


@triton.jit
def gpt_rs_triton_ewise_unary_f32(in_ptr, out_ptr, n, op, BLOCK_SIZE: tl.constexpr):
    pid = tl.program_id(0)
    offs = pid * BLOCK_SIZE + tl.arange(0, BLOCK_SIZE)
    mask = offs < n

    x = tl.load(in_ptr + offs, mask=mask, other=0.0)
    neg = -x
    absv = tl.abs(x)
    expv = tl.exp(x)
    logv = tl.log(x)

    # tanh(x) via exp identity to keep compatibility with Triton versions
    # where tl.math.tanh is unavailable.
    ex2 = tl.exp(2.0 * x)
    tanhv = (ex2 - 1.0) / (ex2 + 1.0)

    # erf approximation (Abramowitz-Stegun 7.1.26).
    sign = tl.where(x < 0.0, -1.0, 1.0)
    ax = tl.abs(x)
    t = 1.0 / (1.0 + 0.3275911 * ax)
    poly = (((((1.061405429 * t - 1.453152027) * t) + 1.421413741) * t - 0.284496736) * t + 0.254829592) * t
    erfv = sign * (1.0 - poly * tl.exp(-(ax * ax)))

    rsqrtv = 1.0 / tl.sqrt(x)
    recipv = 1.0 / x

    out = tl.where(
        op == 0,
        neg,
        tl.where(
            op == 1,
            absv,
            tl.where(
                op == 2,
                expv,
                tl.where(
                    op == 3,
                    logv,
                    tl.where(
                        op == 4,
                        tanhv,
                        tl.where(op == 5, erfv, tl.where(op == 6, rsqrtv, recipv)),
                    ),
                ),
            ),
        ),
    )
    tl.store(out_ptr + offs, out, mask=mask)
