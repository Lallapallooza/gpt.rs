//! Tracing utilities for observing PTIR program capture and execution.
//!
//! The tracing layer exposes lightweight hooks so callers can inspect the PTIR programs
//! generated by lazy graphs. Consumers install a global [`ExecutionTraceSink`] which receives
//! callbacks before and after each backend execution, along with optional pass/rewrite events.

use std::fmt;
use std::path::PathBuf;
use std::sync::{
    atomic::{AtomicU64, Ordering},
    Arc, Mutex, RwLock,
};
use std::time::{Duration, SystemTime};

use serde::Serialize;

use crate::backend::spec::{Program, ValueId};

/// Cache information recorded alongside each executed PTIR program.
#[derive(Debug, Clone, Serialize)]
pub struct ProgramCacheInfo {
    /// True when the arena reused a previously built plan for this signature.
    pub plan_cache_hit: bool,
    /// True when the global `Program` cache was hit (optimizer was not re-run).
    pub program_cache_hit: bool,
}

/// Describes the kind of PTIR program being executed.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "kind", content = "payload")]
pub enum ProgramKind {
    /// Program generated to materialise a specific value identifier.
    Materialize { values: Vec<ValueId> },
    /// Program generated during explicit flushing (e.g., full-graph execution).
    FlushAll,
    /// Custom tag supplied by higher-level callers.
    Custom { label: String },
}

impl ProgramKind {
    pub fn label(&self) -> &str {
        match self {
            ProgramKind::Materialize { .. } => "materialize",
            ProgramKind::FlushAll => "flush_all",
            ProgramKind::Custom { label } => label.as_str(),
        }
    }
}

impl fmt::Display for ProgramKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ProgramKind::Materialize { values } => {
                if let Some(first) = values.first() {
                    write!(f, "materialize_%{}", first.0)
                } else {
                    write!(f, "materialize")
                }
            }
            ProgramKind::FlushAll => write!(f, "flush_all"),
            ProgramKind::Custom { label } => write!(f, "{label}"),
        }
    }
}

/// Metadata provided alongside each PTIR execution.
#[derive(Debug, Clone, Serialize)]
pub struct ProgramContext {
    pub trace_id: u64,
    pub graph_id: usize,
    pub backend: String,
    pub plan_hash: u64,
    pub cache: ProgramCacheInfo,
    pub targets: Vec<ValueId>,
    pub outputs: Vec<ValueId>,
    pub exports: Vec<ValueId>,
    pub timestamp: SystemTime,
    pub kind: ProgramKind,
}

/// Status reported after executing a PTIR program.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "status", content = "details")]
pub enum ProgramStatus {
    Success,
    Failure { message: String },
}

/// Summary emitted once a PTIR program finishes (or fails).
#[derive(Debug, Clone, Serialize)]
pub struct ProgramStats {
    pub duration: Duration,
    pub output_count: usize,
    pub status: ProgramStatus,
}

/// Events emitted by the pass manager or rewrite pipeline.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "event", content = "data")]
pub enum PassEventKind {
    PassStart {
        name: String,
    },
    PassEnd {
        name: String,
        status: PassStatus,
    },
    RewriteApplied {
        pass: String,
        description: String,
    },
    OptimizerPassStats {
        run_id: Option<usize>,
        function: String,
        pass: String,
        stats: OptimizerPassStats,
    },
}

/// Result of running a pass.
#[derive(Debug, Clone, Serialize)]
#[serde(tag = "result")]
pub enum PassStatus {
    Success,
    Failure { message: String },
}

/// Payload describing a pass-related event.
#[derive(Debug, Clone, Serialize)]
pub struct PassEvent {
    pub timestamp: SystemTime,
    pub trace_id: Option<u64>,
    pub kind: PassEventKind,
}

/// Optimizer statistics collected for a single pass run.
#[derive(Debug, Clone, Serialize)]
pub struct OptimizerPassStats {
    pub changed: bool,
    pub iterations: usize,
    pub rewrites_applied: usize,
    pub erased_insts: usize,
    pub body_len: usize,
}

/// Receives callbacks around PTIR program execution and pass activity.
pub trait ExecutionTraceSink: Send + Sync {
    fn before_program(&self, context: &ProgramContext, program: &Program);
    fn after_program(&self, context: &ProgramContext, stats: &ProgramStats);

    fn on_pass_event(&self, _event: &PassEvent) {}
}

static GLOBAL_TRACE_SINK: RwLock<Option<Arc<dyn ExecutionTraceSink>>> = RwLock::new(None);
static TRACE_ID_COUNTER: AtomicU64 = AtomicU64::new(0);

/// Guard returned when installing a trace sink. Restores the previous sink on drop.
pub struct TraceGuard {
    previous: Option<Arc<dyn ExecutionTraceSink>>,
    active: bool,
}

impl Drop for TraceGuard {
    fn drop(&mut self) {
        if self.active {
            let mut lock = GLOBAL_TRACE_SINK
                .write()
                .unwrap_or_else(|poisoned| poisoned.into_inner());
            *lock = self.previous.take();
            self.active = false;
        }
    }
}

/// Installs a global execution trace sink, returning a guard that restores the previous sink.
pub fn install_global_sink(sink: Arc<dyn ExecutionTraceSink>) -> TraceGuard {
    let mut lock = GLOBAL_TRACE_SINK
        .write()
        .unwrap_or_else(|poisoned| poisoned.into_inner());
    let previous = lock.clone();
    *lock = Some(sink);
    TraceGuard {
        previous,
        active: true,
    }
}

/// Returns the currently installed global sink, if any.
pub fn current_sink() -> Option<Arc<dyn ExecutionTraceSink>> {
    GLOBAL_TRACE_SINK
        .read()
        .unwrap_or_else(|poisoned| poisoned.into_inner())
        .clone()
}

/// Allocates a fresh trace identifier for program execution.
pub fn next_trace_id() -> u64 {
    TRACE_ID_COUNTER.fetch_add(1, Ordering::Relaxed)
}

/// Emits a pass event to the current sink, if present.
pub fn emit_pass_event(event: PassEvent) {
    if let Some(sink) = current_sink() {
        sink.on_pass_event(&event);
    }
}

/// Configuration flags for the [`FileTraceSink`].
#[derive(Debug, Clone)]
pub struct FileTraceOptions {
    pub emit_ptir: bool,
    pub emit_json: bool,
    pub emit_pass_events: bool,
    pub dump_filter: ProgramDumpFilter,
    pub emit_execution_log: bool,
}

impl Default for FileTraceOptions {
    fn default() -> Self {
        Self {
            emit_ptir: true,
            emit_json: true,
            emit_pass_events: true,
            dump_filter: ProgramDumpFilter::AllExecutions,
            emit_execution_log: true,
        }
    }
}

/// Controls which program executions are materialized as per-run directories under a dump root.
#[derive(Debug, Clone, Copy)]
pub enum ProgramDumpFilter {
    /// Dump every backend program execution (current behavior).
    AllExecutions,
    /// Dump only when a program is newly compiled (miss in the global program cache).
    ///
    /// All executions are still recorded in `executions.jsonl` when enabled.
    CompileOnly,
}

/// File-backed sink that stores PTIR programs and metadata on disk.
pub struct FileTraceSink {
    root: PathBuf,
    options: FileTraceOptions,
    sequence: AtomicU64,
    runs: Mutex<std::collections::HashMap<u64, RunRecord>>,
    pass_log: Mutex<Option<std::fs::File>>,
    execution_log: Mutex<Option<std::fs::File>>,
}

impl FileTraceSink {
    pub fn new(root: PathBuf) -> std::io::Result<Self> {
        std::fs::create_dir_all(&root)?;
        Ok(Self {
            root,
            options: FileTraceOptions::default(),
            sequence: AtomicU64::new(0),
            runs: Mutex::new(std::collections::HashMap::new()),
            pass_log: Mutex::new(None),
            execution_log: Mutex::new(None),
        })
    }

    pub fn with_options(root: PathBuf, options: FileTraceOptions) -> std::io::Result<Self> {
        std::fs::create_dir_all(&root)?;
        Ok(Self {
            root,
            options,
            sequence: AtomicU64::new(0),
            runs: Mutex::new(std::collections::HashMap::new()),
            pass_log: Mutex::new(None),
            execution_log: Mutex::new(None),
        })
    }

    fn reserve_dir(&self, context: &ProgramContext) -> std::io::Result<PathBuf> {
        let idx = self.sequence.fetch_add(1, Ordering::Relaxed);
        let dir_name = format!("{idx:05}_{}", context.kind);
        let path = self.root.join(dir_name);
        std::fs::create_dir_all(&path)?;
        Ok(path)
    }

    fn should_dump_execution(&self, context: &ProgramContext) -> bool {
        match self.options.dump_filter {
            ProgramDumpFilter::AllExecutions => true,
            ProgramDumpFilter::CompileOnly => !context.cache.program_cache_hit,
        }
    }

    fn append_execution_record(&self, record: &ExecutionRecord<'_>) {
        if !self.options.emit_execution_log {
            return;
        }
        if let Ok(mut file_guard) = self.execution_log.lock() {
            if file_guard.is_none() {
                let path = self.root.join("executions.jsonl");
                if let Ok(file) = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)
                {
                    *file_guard = Some(file);
                }
            }
            if let Some(file) = file_guard.as_mut() {
                if let Ok(json) = serde_json::to_string(record) {
                    let _ = writeln!(file, "{json}");
                }
            }
        }
    }
}

#[derive(Debug)]
struct RunRecord {
    dir: Option<PathBuf>,
    dumped: bool,
    buffered_ptir: Option<String>,
    buffered_json: Option<String>,
}

#[derive(Serialize)]
struct ExecutionRecord<'a> {
    context: &'a ProgramContext,
    stats: &'a ProgramStats,
    dumped: bool,
}

impl ExecutionTraceSink for FileTraceSink {
    fn before_program(&self, context: &ProgramContext, program: &Program) {
        let should_dump = self.should_dump_execution(context);
        let mut record = RunRecord {
            dir: None,
            dumped: false,
            buffered_ptir: None,
            buffered_json: None,
        };

        if should_dump {
            if let Ok(dir) = self.reserve_dir(context) {
                if self.options.emit_ptir {
                    let _ = std::fs::write(dir.join("program.ptir"), program.to_string());
                }
                if self.options.emit_json {
                    if let Ok(json) = serde_json::to_string_pretty(program) {
                        let _ = std::fs::write(dir.join("program.json"), json);
                    }
                }
                if let Ok(meta) = serde_json::to_string_pretty(&context) {
                    let _ = std::fs::write(dir.join("meta.json"), meta);
                }
                record.dir = Some(dir);
                record.dumped = true;
            }
        } else {
            // Buffer program artifacts so failures can still be materialized as on-disk dumps.
            if self.options.emit_ptir {
                record.buffered_ptir = Some(program.to_string());
            }
            if self.options.emit_json {
                record.buffered_json = serde_json::to_string_pretty(program).ok();
            }
        }

        if let Ok(mut runs) = self.runs.lock() {
            runs.insert(context.trace_id, record);
        }
    }

    fn after_program(&self, context: &ProgramContext, stats: &ProgramStats) {
        let record = if let Ok(mut runs) = self.runs.lock() {
            runs.remove(&context.trace_id)
        } else {
            None
        };

        let dumped = record.as_ref().is_some_and(|r| r.dumped);

        if let Some(record) = record {
            if let Some(dir) = record.dir {
                if let Ok(json) = serde_json::to_string_pretty(stats) {
                    let _ = std::fs::write(dir.join("stats.json"), json);
                }
            } else if matches!(stats.status, ProgramStatus::Failure { .. }) {
                // Materialize a dump directory on failure, even in CompileOnly mode.
                if let Ok(dir) = self.reserve_dir(context) {
                    if let Some(ptir) = record.buffered_ptir {
                        let _ = std::fs::write(dir.join("program.ptir"), ptir);
                    }
                    if let Some(json) = record.buffered_json {
                        let _ = std::fs::write(dir.join("program.json"), json);
                    }
                    if let Ok(meta) = serde_json::to_string_pretty(&context) {
                        let _ = std::fs::write(dir.join("meta.json"), meta);
                    }
                    if let Ok(json) = serde_json::to_string_pretty(stats) {
                        let _ = std::fs::write(dir.join("stats.json"), json);
                    }
                }
            }
        }

        self.append_execution_record(&ExecutionRecord {
            context,
            stats,
            dumped,
        });
    }

    fn on_pass_event(&self, event: &PassEvent) {
        if !self.options.emit_pass_events {
            return;
        }
        if let Ok(mut file_guard) = self.pass_log.lock() {
            if file_guard.is_none() {
                let path = self.root.join("passes.jsonl");
                if let Ok(file) = std::fs::OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)
                {
                    *file_guard = Some(file);
                }
            }
            if let Some(file) = file_guard.as_mut() {
                if let Ok(json) = serde_json::to_string(event) {
                    let _ = writeln!(file, "{json}");
                }
            }
        }
    }
}

use std::io::Write;
